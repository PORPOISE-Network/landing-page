<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="keywords"
        content="PORPOISE, Proof of Reputation, Protocol, zero knowledge proof, zkSNARK, crypto, Mina Protocol, Protokit, surveys, predictions">
    <meta name="description" content="Take a PORPOISE Survey">
    <title>PORPOISE Network</title>

    <link rel="stylesheet" href="/take-survey.css">

    <script>
        let prediction;
        let surveyLeafs = [];
        let paddedSurveyLeafs;
        let surveyRoot;
        let deadlineTimestamp; 

        const urlPrefix = 'https://porpoise.network/take-survey.html?';
        const urlEncodedDoor = '%F0%9F%9A%AA';
        const urlEncodedSalt = '%F0%9F%A7%82';
        const urlEncodedCheck = '%E2%9C%94';



        function getSurveyComponents() {

            // Get the search parameters from the URL
            //const urlParams = new URLSearchParams(window.location.search);
            const queryString = window.location.search;
            const urlParams = parseQueryString(queryString.slice(1, queryString.size));

            const numParams = Object.keys(urlParams).length;
            console.log("URL Params: ", urlParams);

            if (numParams >= 5) {
                const numOptions = numParams - 3;
                console.log("Number of options: ", numOptions);

                // Retrieve the body, deadline, and oracle content
                const dolphin = urlParams['🐬'];
                const alarmclock = urlParams['⏰'];
                const oracle = urlParams['🔮'];

                console.log('🐬 Dolphin:', dolphin);
                console.log('⏰ Deadline:', alarmclock);
                console.log('🔮 Oracle: ', oracle);

                // check if the required parameters where supplied
                if (dolphin === null) {
                    document.getElementById('🐬').innerHTML = "Missing 🐬 in URL.";
                    return 0;
                } else {
                    document.getElementById('🐬').innerHTML = '🐬 ' + dolphin.replace(/-/g, ' ');
                    surveyLeafs.push(dolphin);
                }

                if (alarmclock === null) {
                    document.getElementById('🐬').innerHTML = "Missing ⏰ in URL.";
                    return 0;
                } else {
                    deadlineTimestamp = alarmclock;
                    updateCountdown();
                    surveyLeafs.push(alarmclock);
                }

                if (oracle === null) {
                    document.getElementById('⏰').innerHTML = '';
                    document.getElementById('🐬').innerHTML = "Missing 🔮 in URL.";
                    return 0;
                } else {
                    if (oracle === '0') {
                        document.getElementById('🔮').innerHTML = '🔮: No oracle for this survey.';
                    } else {
                        document.getElementById('🔮').innerHTML = '🔮: ' + oracle;
                    }
                    surveyLeafs.push(oracle);
                }

                // loop over the options and store in an options array
                const options = [];
                for (let i = 1; i <= numOptions; i++) {
                    let option = urlParams['🗳' + i];
                    if (option !== undefined) {
                        options.push(option);
                        surveyLeafs.push(option);
                    }
                }

                // if there are not at least two options, then the survey is not valid
                if (options.length < 2) {
                    document.getElementById('⏰').innerHTML = '';
                    document.getElementById('🔮').innerHTML = '';
                    document.getElementById('🐬').innerHTML = "A PORPOISE survey must have at least 2 options (🗳1 & 🗳2)."
                    return 0;
                } else {
                    setOptions(options);
                    paddedSurveyLeafs = padArrayToPowerOfTwo(surveyLeafs, '0');
                    computeMerkleRoot(paddedSurveyLeafs).then((root) => {
                        console.log("Merkle Root: ", root);
                        surveyRoot = root;
                    })
                }
            } else {

                const message = "Not enough emojis for a PORPOISE-compatible survey.";
                document.getElementById('🐬').innerHTML = message;
                console.log(message)
            }
            return 1;
        }

        // we need this function because there seem to be a lot of mobile browsers
        // that don't like URLSearchParams
        function parseQueryString(queryString) {

            if (!queryString) {
                return {};
            }

            // Split the query string into key-value pairs
            const queryParams = queryString.split('&');

            // Create an object to store the parsed parameters
            const params = {};

            // Iterate over each key-value pair and populate the object
            queryParams.forEach(param => {
                const [key, value] = param.split('=');
                params[decodeURIComponent(key)] = decodeURIComponent(value);
            });

            return params;
        }

        function generatePrediction() {
            // hash the prediction
            if (prediction === undefined) {
                document.getElementById("prediction").innerText = "You must make a prediction first!"
                return 0;
            } else {
                hashString(prediction).then((predictionHash) => {
                    console.log("Prediction Hash: ", predictionHash);
                    const predictionSalt = generateRandomString(18);
                    console.log("Prediction Salt: ", predictionSalt);
                    hashString(predictionSalt + predictionHash + surveyRoot).then((predictionCommitment) => {

                        postString = `I just made a prediction with 🐬#PORPOISENetwork!: ${predictionCommitment}\n\nMake your own here:\n${window.location.href}`

                        let predictionElement = document.getElementById("prediction");
                        predictionElement.innerHTML = "Commitment: " + predictionCommitment.slice(0, 5) + '...  ';
                        predictionElement.title = "Commits you to a specific prediction. Post it somewhere to build your reputation!";

                        let copyPredictionElement = document.createElement('button');
                        copyPredictionElement.setAttribute('class', 'button-28');
                        copyPredictionElement.setAttribute('id', 'prediction-commitment-📋');
                        copyPredictionElement.setAttribute('value', postString);
                        copyPredictionElement.setAttribute('onclick', 'copyCommitment()')
                        copyPredictionElement.innerText = '📋';
                        predictionElement.appendChild(copyPredictionElement);

                        let saltElement = document.getElementById("salt");
                        saltElement.innerText = "🧂: " + predictionSalt;//.slice(0, 13) + '...  ';
                        saltElement.title = "Kind of like a password that helps you reveal your prediction commitment later."
                        let copySaltElement = document.createElement('button');
                        copySaltElement.setAttribute('class', 'button-28');
                        copySaltElement.setAttribute('id', 'prediction-🧂-📋');
                        copySaltElement.setAttribute('value', predictionSalt);
                        copySaltElement.setAttribute('onclick', 'copySalt()')
                        copySaltElement.innerText = '📋';
                        //saltElement.appendChild(copySaltElement);

                        savePrediction(prediction, predictionSalt, predictionCommitment);
                        document.getElementById('save-prediction').innerText = '✅';
                    });
                })
            }
        }

        function copyCommitment() {
            // Get the button element
            const button = document.getElementById('prediction-commitment-📋');

            // Create a temporary textarea
            const textarea = document.createElement('textarea');
            textarea.value = button.value; // Use textContent instead of value

            // Append the textarea to the document
            document.body.appendChild(textarea);

            // Select the text in the textarea
            textarea.select();
            textarea.setSelectionRange(0, 99999); // For mobile devices

            // Copy the selected text to the clipboard
            document.execCommand('copy');

            // Remove the temporary textarea
            document.body.removeChild(textarea);

            button.innerText = '✅';
        }

        function copySalt() {
            // Get the button element
            const button = document.getElementById('prediction-🧂-📋');

            // Create a temporary textarea
            const textarea = document.createElement('textarea');
            textarea.value = button.value; // Use textContent instead of value

            // Append the textarea to the document
            document.body.appendChild(textarea);

            // Select the text in the textarea
            textarea.select();
            textarea.setSelectionRange(0, 99999); // For mobile devices

            // Copy the selected text to the clipboard
            document.execCommand('copy');

            // Remove the temporary textarea
            document.body.removeChild(textarea);

            button.innerText = '✅';
        }

        function savePrediction(prediction, predictionSalt, predictionCommitment) {
            const predictionLink = window.location.href + '&' + urlEncodedDoor + '=' + predictionCommitment + '&' +
                urlEncodedSalt + '=' + predictionSalt + '&' + urlEncodedCheck + '=' + prediction;

            localStorage.setItem(surveyRoot, predictionLink);
            const storedLink = localStorage.getItem(surveyRoot);
            console.log("Prediction Link: ", storedLink);
        }

        function setOptions(optionsArray) {
            let optionsContainer = document.getElementById('🗳')

            for (let i = 0; i < optionsArray.length; i++) {
                console.log("Option", i, ": ", optionsArray[i]);
                let paragraphElement = document.createElement('p');
                paragraphElement.innerText = '🗳' + (i + 1) + ". " + optionsArray[i].replace(/-/g, ' ');

                let inputElement = document.createElement('input');
                inputElement.setAttribute('type', 'radio');
                inputElement.setAttribute('name', 'options');
                inputElement.setAttribute('class', 'radio-buttons')
                inputElement.setAttribute('value', optionsArray[i]);
                inputElement.setAttribute('id', '🗳' + (i + 1) + 'input');
                paragraphElement.appendChild(inputElement);


                optionsContainer.appendChild(paragraphElement);
            }

            const radioButtons = document.querySelectorAll('input[type="radio"]');

            // Add event listener to each radio button
            radioButtons.forEach(button => {
                button.addEventListener('change', () => {
                    // Check which radio button is selected
                    if (button.checked) {
                        console.log('Selected option:', button.value);
                        prediction = button.value;
                    }
                });
            });
        }

        function convertUTCtoDate(utcTimestamp) {
            // Create a new Date object with the UTC timestamp
            // the UTC timestamp should be in miliseconds
            const date = new Date(parseInt(utcTimestamp, 10));

            // Get the individual components of the date and time
            const year = date.getFullYear();
            const month = date.getMonth() + 1; // Months are zero-indexed, so add 1
            const day = date.getDate();
            const hours = date.getHours();
            const minutes = date.getMinutes();
            const seconds = date.getSeconds();

            const userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            console.log("User's timezone:", userTimezone);

            const formattedDateTime = `${year}-${month}-${day} ${hours}:${minutes}:${seconds} ${userTimezone}`;

            return formattedDateTime;
        }

        function updateCountdown() {
            const currentTime = new Date().getTime();
            const timeDifference = deadlineTimestamp - currentTime;

            if (timeDifference > 0) {
                const days = Math.floor(timeDifference / (1000 * 60 * 60 * 24));
                const hours = Math.floor((timeDifference % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const minutes = Math.floor((timeDifference % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((timeDifference % (1000 * 60)) / 1000);

                // Display the countdown in the element
                document.getElementById('⏰').innerHTML = '⏰: ' + `${days}d ${hours}h ${minutes}m ${seconds}s`;

                // Update every second
                setTimeout(updateCountdown, 1000);
            } else {
                // Display a message when the countdown reaches zero
                document.getElementById('⏰').innerHTML = '⏰: 💀 Time is up!';
            }
        }

        function generateRandomString(length) {
            const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let randomString = '';

            for (let i = 0; i < length; i++) {
                const randomIndex = Math.floor(Math.random() * charset.length);
                randomString += charset[randomIndex];
            }

            return randomString;
        }

        function padArrayToPowerOfTwo(arr, paddingValue) {
            // Check if the array length is already a power of 2
            if ((arr.length & (arr.length - 1)) === 0) {
                return arr; // Array length is already a power of 2, no padding needed
            }

            // Calculate the next power of 2 greater than the current length
            const nextPowerOfTwo = Math.pow(2, Math.ceil(Math.log2(arr.length)));

            // Calculate the number of elements to pad
            const paddingCount = nextPowerOfTwo - arr.length;

            // Pad the array with the specified paddingValue (default is undefined)
            return arr.concat(new Array(paddingCount).fill(paddingValue));
        }

        // Function to compute the Merkle root hash from an array of strings
        async function computeMerkleRoot(strings) {
            if (strings.length === 0) {
                return null;
            }

            // Base case: if there's only one element, return its hash
            if (strings.length === 1) {
                return await hashString(strings[0]);
            }

            // Recursive case: compute hash of pairs until a single hash is obtained
            const pairedHashes = [];
            for (let i = 0; i < strings.length; i += 2) {
                const left = strings[i];
                const right = (i + 1 < strings.length) ? strings[i + 1] : '';
                const pairHash = await hashString(left + right);
                pairedHashes.push(pairHash);
            }

            // Recursively compute the Merkle root for the paired hashes
            return await computeMerkleRoot(pairedHashes);
        }

        // Function to hash a string (use any suitable hash function)
        function hashString(str) {
            const encoder = new TextEncoder();
            const data = encoder.encode(str);

            return crypto.subtle.digest('SHA-256', data).then(hashBuffer => {
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(byte => byte.toString(16).padStart(2, '0')).join('');
            });
        }
    </script>
</head>

<body onload="getSurveyComponents();">
    <header>
        <h1><a href="/">PORPOISE</a> Survey:</h1>
    </header>

    <h2 id="🐬"></h2>

    <fieldset id="🗳" class="options">
        <legend>Make a Predcition:</legend>
    </fieldset>
    <p id="⏰" title="Remaining time for making predictions." class="timer"></p>

    <div>
        <button class="button-28" id="save-prediction" onclick="generatePrediction()"
            title="Save your prediction to share later and post your commitment now.">💾</button>
        <div>
            <p id="prediction"></p>
        </div>
        <p id="salt"></p>
    </div>

    <a href="https://twitter.com/zkporpoise?ref_src=twsrc%5Etfw" class="twitter-follow-button"
        data-show-count="false">Follow @zkporpoise</a>
    <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

    <p id="🔮" title="Event oracle contract address."></p>

    <footer>
        <p>
            &copy; 2024 PORPOISE Network. All rights reserved.
        </p>
    </footer>
</body>

</html>